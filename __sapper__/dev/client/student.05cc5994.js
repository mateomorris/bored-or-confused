import { S as SvelteComponentDev, i as init, s as safe_not_equal, e as element, o as text, u as space, a as claim_element, b as children, p as claim_text, d as detach, g as add_location, f as attr, h as insert, q as append, r as set_data, G as add_render_callback, H as create_in_transition, n as noop, l as transition_out, C as check_outros, t as transition_in, B as group_outros, v as empty, x as mount_component, z as destroy_component, D as listen, I as update_keyed_each, K as outro_and_destroy_block, E as run_all, L as prevent_default } from './chunk.66308fb8.js';
import { f as fade } from './chunk.d453e17d.js';
import { d as db, m as moment, f as firebase } from './chunk.4d7af833.js';

/* src/components/FeedbackSent.svelte generated by Svelte v3.6.10 */

const file = "src/components/FeedbackSent.svelte";

function create_fragment(ctx) {
	var div3, article, div2, nav, div1, div0, p, strong, t0, t1, t2_value = ctx.item.formattedTime, t2, div3_intro;

	return {
		c: function create() {
			div3 = element("div");
			article = element("article");
			div2 = element("div");
			nav = element("nav");
			div1 = element("div");
			div0 = element("div");
			p = element("p");
			strong = element("strong");
			t0 = text("Feedback sent");
			t1 = space();
			t2 = text(t2_value);
			this.h();
		},

		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			article = claim_element(div3_nodes, "ARTICLE", { class: true }, false);
			var article_nodes = children(article);

			div2 = claim_element(article_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			nav = claim_element(div2_nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			div1 = claim_element(nav_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			p = claim_element(div0_nodes, "P", {}, false);
			var p_nodes = children(p);

			strong = claim_element(p_nodes, "STRONG", {}, false);
			var strong_nodes = children(strong);

			t0 = claim_text(strong_nodes, "Feedback sent");
			strong_nodes.forEach(detach);
			t1 = claim_text(p_nodes, " ");
			t2 = claim_text(p_nodes, t2_value);
			p_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			nav_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			article_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(strong, file, 13, 14, 299);
			add_location(p, file, 12, 12, 281);
			attr(div0, "class", "content");
			add_location(div0, file, 11, 10, 247);
			attr(div1, "class", "level-left");
			add_location(div1, file, 10, 8, 212);
			attr(nav, "class", "level is-mobile");
			add_location(nav, file, 9, 6, 174);
			attr(div2, "class", "media-content");
			add_location(div2, file, 8, 4, 140);
			attr(article, "class", "media");
			add_location(article, file, 7, 2, 112);
			attr(div3, "class", "box");
			add_location(div3, file, 6, 0, 84);
		},

		m: function mount(target, anchor) {
			insert(target, div3, anchor);
			append(div3, article);
			append(article, div2);
			append(div2, nav);
			append(nav, div1);
			append(div1, div0);
			append(div0, p);
			append(p, strong);
			append(strong, t0);
			append(p, t1);
			append(p, t2);
		},

		p: function update(changed, ctx) {
			if ((changed.item) && t2_value !== (t2_value = ctx.item.formattedTime)) {
				set_data(t2, t2_value);
			}
		},

		i: function intro(local) {
			if (!div3_intro) {
				add_render_callback(() => {
					div3_intro = create_in_transition(div3, fade, {});
					div3_intro.start();
				});
			}
		},

		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(div3);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { item } = $$props;

	const writable_props = ['item'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<FeedbackSent> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('item' in $$props) $$invalidate('item', item = $$props.item);
	};

	return { item };
}

class FeedbackSent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["item"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.item === undefined && !('item' in props)) {
			console.warn("<FeedbackSent> was created without expected prop 'item'");
		}
	}

	get item() {
		throw new Error("<FeedbackSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<FeedbackSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/student.svelte generated by Svelte v3.6.10 */

const file$1 = "src/routes/student.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.item = list[i];
	return child_ctx;
}

// (103:2) {:else}
function create_else_block(ctx) {
	var div1, div0;

	function select_block_type_1(ctx) {
		if (!ctx.inClass) return create_if_block_2;
		return create_else_block_1;
	}

	var current_block_type = select_block_type_1(ctx);
	var if_block = current_block_type(ctx);

	return {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if_block.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "class", "control");
			add_location(div0, file$1, 104, 6, 2369);
			attr(div1, "class", "field");
			add_location(div1, file$1, 103, 4, 2343);
		},

		m: function mount(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_block.m(div0, null);
		},

		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(div1);
			}

			if_block.d();
		}
	};
}

// (88:2) {#if signedIn}
function create_if_block(ctx) {
	var div2, div0, button0, t0, t1, div1, button1, t2, t3, hr, t4, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current, dispose;

	var each_value = ctx.feedback;

	const get_key = ctx => ctx.item.created;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			button0 = element("button");
			t0 = text("Bored ðŸ˜´");
			t1 = space();
			div1 = element("div");
			button1 = element("button");
			t2 = text("Confused ðŸ˜•");
			t3 = space();
			hr = element("hr");
			t4 = space();

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

			each_1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			button0 = claim_element(div0_nodes, "BUTTON", { class: true, value: true }, false);
			var button0_nodes = children(button0);

			t0 = claim_text(button0_nodes, "Bored ðŸ˜´");
			button0_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t1 = claim_text(div2_nodes, "\n      ");

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			button1 = claim_element(div1_nodes, "BUTTON", { class: true, value: true }, false);
			var button1_nodes = children(button1);

			t2 = claim_text(button1_nodes, "Confused ðŸ˜•");
			button1_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t3 = claim_text(nodes, "\n    ");

			hr = claim_element(nodes, "HR", {}, false);
			var hr_nodes = children(hr);

			hr_nodes.forEach(detach);
			t4 = claim_text(nodes, "\n    ");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(nodes);

			each_1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr(button0, "class", "button is-large is-dark is-fullwidth svelte-1gbg17k");
			button0.value = "bored";
			add_location(button0, file$1, 90, 8, 1887);
			attr(div0, "class", "column");
			add_location(div0, file$1, 89, 6, 1858);
			attr(button1, "class", "button is-large is-dark is-fullwidth svelte-1gbg17k");
			button1.value = "confused";
			add_location(button1, file$1, 93, 8, 2043);
			attr(div1, "class", "column");
			add_location(div1, file$1, 92, 6, 2014);
			attr(div2, "class", "columns");
			add_location(div2, file$1, 88, 4, 1830);
			add_location(hr, file$1, 96, 4, 2185);

			dispose = [
				listen(button0, "click", ctx.handleClick),
				listen(button1, "click", ctx.handleClick)
			];
		},

		m: function mount(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, button0);
			append(button0, t0);
			append(div2, t1);
			append(div2, div1);
			append(div1, button1);
			append(button1, t2);
			insert(target, t3, anchor);
			insert(target, hr, anchor);
			insert(target, t4, anchor);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			const each_value = ctx.feedback;

			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
			check_outros();
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div2);
				detach(t3);
				detach(hr);
				detach(t4);
			}

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

			if (detaching) {
				detach(each_1_anchor);
			}

			run_all(dispose);
		}
	};
}

// (111:4) {:else}
function create_else_block_1(ctx) {
	var form, label, t0, t1, input, dispose;

	return {
		c: function create() {
			form = element("form");
			label = element("label");
			t0 = text("Name");
			t1 = space();
			input = element("input");
			this.h();
		},

		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {}, false);
			var form_nodes = children(form);

			label = claim_element(form_nodes, "LABEL", { class: true }, false);
			var label_nodes = children(label);

			t0 = claim_text(label_nodes, "Name");
			label_nodes.forEach(detach);
			t1 = claim_text(form_nodes, "\n\t\t\t\t\t\t");

			input = claim_element(form_nodes, "INPUT", { class: true, type: true, placeholder: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach);
			form_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(label, "class", "label");
			add_location(label, file$1, 112, 6, 2691);
			attr(input, "class", "input is-large");
			attr(input, "type", "text");
			attr(input, "placeholder", "Name");
			add_location(input, file$1, 113, 6, 2731);
			add_location(form, file$1, 111, 5, 2627);

			dispose = [
				listen(input, "input", ctx.input_input_handler_1),
				listen(form, "submit", prevent_default(ctx.submit_handler))
			];
		},

		m: function mount(target, anchor) {
			insert(target, form, anchor);
			append(form, label);
			append(label, t0);
			append(form, t1);
			append(form, input);

			input.value = ctx.name;
		},

		p: function update(changed, ctx) {
			if (changed.name && (input.value !== ctx.name)) input.value = ctx.name;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(form);
			}

			run_all(dispose);
		}
	};
}

// (106:4) {#if !inClass}
function create_if_block_2(ctx) {
	var form, label, t0, t1, input, dispose;

	return {
		c: function create() {
			form = element("form");
			label = element("label");
			t0 = text("Class ID");
			t1 = space();
			input = element("input");
			this.h();
		},

		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {}, false);
			var form_nodes = children(form);

			label = claim_element(form_nodes, "LABEL", { class: true }, false);
			var label_nodes = children(label);

			t0 = claim_text(label_nodes, "Class ID");
			label_nodes.forEach(detach);
			t1 = claim_text(form_nodes, "\n\t\t\t\t\t\t");

			input = claim_element(form_nodes, "INPUT", { class: true, type: true, placeholder: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach);
			form_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(label, "class", "label");
			add_location(label, file$1, 107, 6, 2466);
			attr(input, "class", "input is-large");
			attr(input, "type", "text");
			attr(input, "placeholder", "Class ID");
			add_location(input, file$1, 108, 6, 2510);
			add_location(form, file$1, 106, 5, 2415);

			dispose = [
				listen(input, "input", ctx.input_input_handler),
				listen(form, "submit", prevent_default(ctx.enterClass))
			];
		},

		m: function mount(target, anchor) {
			insert(target, form, anchor);
			append(form, label);
			append(label, t0);
			append(form, t1);
			append(form, input);

			input.value = ctx.classId;
		},

		p: function update(changed, ctx) {
			if (changed.classId && (input.value !== ctx.classId)) input.value = ctx.classId;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(form);
			}

			run_all(dispose);
		}
	};
}

// (99:4) {#if item.created >= clearDate}
function create_if_block_1(ctx) {
	var current;

	var feedbacksent = new FeedbackSent({
		props: { item: ctx.item },
		$$inline: true
	});

	return {
		c: function create() {
			feedbacksent.$$.fragment.c();
		},

		l: function claim(nodes) {
			feedbacksent.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(feedbacksent, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var feedbacksent_changes = {};
			if (changed.feedback) feedbacksent_changes.item = ctx.item;
			feedbacksent.$set(feedbacksent_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(feedbacksent.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(feedbacksent.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(feedbacksent, detaching);
		}
	};
}

// (98:4) {#each feedback as item (item.created)}
function create_each_block(key_1, ctx) {
	var first, if_block_anchor, current;

	var if_block = (ctx.item.created >= ctx.clearDate) && create_if_block_1(ctx);

	return {
		key: key_1,

		first: null,

		c: function create() {
			first = empty();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			first = empty();
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			this.first = first;
		},

		m: function mount(target, anchor) {
			insert(target, first, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.item.created >= ctx.clearDate) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(first);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

function create_fragment$1(ctx) {
	var div, h1, t0, t1, h2, t2, t3, current_block_type_index, if_block, current;

	var if_block_creators = [
		create_if_block,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.signedIn) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text("Bored or Confused");
			t1 = space();
			h2 = element("h2");
			t2 = text("A tool for discreetly giving feedback to an instructor during a lecture. Great for introverts.");
			t3 = space();
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			h1 = claim_element(div_nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t0 = claim_text(h1_nodes, "Bored or Confused");
			h1_nodes.forEach(detach);
			t1 = claim_text(div_nodes, "\n\t");

			h2 = claim_element(div_nodes, "H2", { class: true }, false);
			var h2_nodes = children(h2);

			t2 = claim_text(h2_nodes, "A tool for discreetly giving feedback to an instructor during a lecture. Great for introverts.");
			h2_nodes.forEach(detach);
			t3 = claim_text(div_nodes, "\n  ");
			if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(h1, "class", "title");
			add_location(h1, file$1, 83, 1, 1641);
			attr(h2, "class", "subtitle");
			add_location(h2, file$1, 84, 1, 1683);
			attr(div, "class", "container");
			add_location(div, file$1, 82, 0, 1616);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			append(div, h1);
			append(h1, t0);
			append(div, t1);
			append(div, h2);
			append(h2, t2);
			append(div, t3);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	


	let classId = '';
	let name = ''; 
	let signedIn = false;
	let feedback = [];
  let clearDate = new Date();

	let inClass = false;


	function enterClass() {

		const currentClass = db.collection('classes').doc(classId);

		currentClass.get().then(function(doc) {
				if (doc.exists) {
					$$invalidate('inClass', inClass = true);
					currentClass.onSnapshot(function(doc) {
						let data = doc.data();

						$$invalidate('feedback', feedback = data.feedback
							.filter(i => i.name == name)
							.sort((a, b) => (a.created < b.created) ? 1 : -1)
							.map(stuff => ({
							...stuff,
							formattedTime: moment(stuff.created).fromNow()
						})));
					});
				} else {
					alert('Incorrect class ID');
				}
		}).catch(function(error) {
				console.log("Error getting document:", error);
		});

	}

	function addName(name) {
		$$invalidate('signedIn', signedIn = true);

		db.collection('classes')
			.doc(classId)
			.update({ 
				students: firebase.firestore.FieldValue.arrayUnion(name) 
			});

	}

	function handleClick({ target }) {

		db.collection('classes')
			.doc(classId)
			.update({ 
				feedback: firebase.firestore.FieldValue.arrayUnion({
					name,
					feeling: target.value,
					created: Date.now(),
				}) 
			});

	}

	function input_input_handler() {
		classId = this.value;
		$$invalidate('classId', classId);
	}

	function input_input_handler_1() {
		name = this.value;
		$$invalidate('name', name);
	}

	function submit_handler() { addName(name); }

	return {
		classId,
		name,
		signedIn,
		feedback,
		clearDate,
		inClass,
		enterClass,
		addName,
		handleClick,
		input_input_handler,
		input_input_handler_1,
		submit_handler
	};
}

class Student extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
	}
}

export default Student;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R1ZGVudC4wNWNjNTk5NC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvRmVlZGJhY2tTZW50LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvc3R1ZGVudC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZmFkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuICBleHBvcnQgbGV0IGl0ZW07XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImJveFwiIGluOmZhZGU+XG4gIDxhcnRpY2xlIGNsYXNzPVwibWVkaWFcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWVkaWEtY29udGVudFwiPlxuICAgICAgPG5hdiBjbGFzcz1cImxldmVsIGlzLW1vYmlsZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtbGVmdFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgPHN0cm9uZz5GZWVkYmFjayBzZW50PC9zdHJvbmc+IHtpdGVtLmZvcm1hdHRlZFRpbWV9XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9uYXY+XG4gICAgPC9kaXY+XG4gIDwvYXJ0aWNsZT5cbjwvZGl2PiIsIjxzY3JpcHQ+XG5cdGltcG9ydCBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuXHRpbXBvcnQgeyBmbHksIGZhZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG4gIGltcG9ydCB7IGRiIH0gZnJvbSAnLi4vZmlyZWJhc2UnO1xuICBpbXBvcnQgeyBjb2xsZWN0aW9uRGF0YSB9IGZyb20gJ3J4ZmlyZS9maXJlc3RvcmUnO1xuXHRpbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cdGltcG9ydCB7IG9iamVjdCB9IGZyb20gJ3J4ZmlyZS9kYXRhYmFzZSc7XG5cdGltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50J1xuXG5cdGltcG9ydCBGZWVkYmFja1NlbnQgZnJvbSAnLi4vY29tcG9uZW50cy9GZWVkYmFja1NlbnQuc3ZlbHRlJztcblxuXG5cdGxldCBjbGFzc0lkID0gJyc7XG5cdGxldCBuYW1lID0gJyc7IFxuXHRsZXQgc2lnbmVkSW4gPSBmYWxzZTtcblx0bGV0IGZlZWRiYWNrID0gW107XG4gIGxldCBjbGVhckRhdGUgPSBuZXcgRGF0ZSgpO1xuXG5cdGxldCBpbkNsYXNzID0gZmFsc2U7XG5cblxuXHRmdW5jdGlvbiBlbnRlckNsYXNzKCkge1xuXG5cdFx0Y29uc3QgY3VycmVudENsYXNzID0gZGIuY29sbGVjdGlvbignY2xhc3NlcycpLmRvYyhjbGFzc0lkKTtcblxuXHRcdGN1cnJlbnRDbGFzcy5nZXQoKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuXHRcdFx0XHRpZiAoZG9jLmV4aXN0cykge1xuXHRcdFx0XHRcdGluQ2xhc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGN1cnJlbnRDbGFzcy5vblNuYXBzaG90KGZ1bmN0aW9uKGRvYykge1xuXHRcdFx0XHRcdFx0bGV0IGRhdGEgPSBkb2MuZGF0YSgpO1xuXG5cdFx0XHRcdFx0XHRmZWVkYmFjayA9IGRhdGEuZmVlZGJhY2tcblx0XHRcdFx0XHRcdFx0LmZpbHRlcihpID0+IGkubmFtZSA9PSBuYW1lKVxuXHRcdFx0XHRcdFx0XHQuc29ydCgoYSwgYikgPT4gKGEuY3JlYXRlZCA8IGIuY3JlYXRlZCkgPyAxIDogLTEpXG5cdFx0XHRcdFx0XHRcdC5tYXAoc3R1ZmYgPT4gKHtcblx0XHRcdFx0XHRcdFx0Li4uc3R1ZmYsXG5cdFx0XHRcdFx0XHRcdGZvcm1hdHRlZFRpbWU6IG1vbWVudChzdHVmZi5jcmVhdGVkKS5mcm9tTm93KClcblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhbGVydCgnSW5jb3JyZWN0IGNsYXNzIElEJyk7XG5cdFx0XHRcdH1cblx0XHR9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkVycm9yIGdldHRpbmcgZG9jdW1lbnQ6XCIsIGVycm9yKTtcblx0XHR9KTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkTmFtZShuYW1lKSB7XG5cdFx0c2lnbmVkSW4gPSB0cnVlO1xuXHRcdG5hbWUgPSBuYW1lO1xuXG5cdFx0ZGIuY29sbGVjdGlvbignY2xhc3NlcycpXG5cdFx0XHQuZG9jKGNsYXNzSWQpXG5cdFx0XHQudXBkYXRlKHsgXG5cdFx0XHRcdHN0dWRlbnRzOiBmaXJlYmFzZS5maXJlc3RvcmUuRmllbGRWYWx1ZS5hcnJheVVuaW9uKG5hbWUpIFxuXHRcdFx0fSk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHsgdGFyZ2V0IH0pIHtcblxuXHRcdGRiLmNvbGxlY3Rpb24oJ2NsYXNzZXMnKVxuXHRcdFx0LmRvYyhjbGFzc0lkKVxuXHRcdFx0LnVwZGF0ZSh7IFxuXHRcdFx0XHRmZWVkYmFjazogZmlyZWJhc2UuZmlyZXN0b3JlLkZpZWxkVmFsdWUuYXJyYXlVbmlvbih7XG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRmZWVsaW5nOiB0YXJnZXQudmFsdWUsXG5cdFx0XHRcdFx0Y3JlYXRlZDogRGF0ZS5ub3coKSxcblx0XHRcdFx0fSkgXG5cdFx0XHR9KTtcblxuXHR9XG5cdFxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0YnV0dG9uIHtcblx0XHRoZWlnaHQ6IDUwdmg7XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cblx0PGgxIGNsYXNzPVwidGl0bGVcIj5Cb3JlZCBvciBDb25mdXNlZDwvaDE+XG5cdDxoMiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0QSB0b29sIGZvciBkaXNjcmVldGx5IGdpdmluZyBmZWVkYmFjayB0byBhbiBpbnN0cnVjdG9yIGR1cmluZyBhIGxlY3R1cmUuIEdyZWF0IGZvciBpbnRyb3ZlcnRzLlxuXHQ8L2gyPlxuICB7I2lmIHNpZ25lZElufVxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gaXMtbGFyZ2UgaXMtZGFyayBpcy1mdWxsd2lkdGhcIiBvbjpjbGljaz17aGFuZGxlQ2xpY2t9IHZhbHVlPVwiYm9yZWRcIj5Cb3JlZCDwn5i0PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1sYXJnZSBpcy1kYXJrIGlzLWZ1bGx3aWR0aFwiIG9uOmNsaWNrPXtoYW5kbGVDbGlja30gdmFsdWU9XCJjb25mdXNlZFwiPkNvbmZ1c2VkIPCfmJU8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxoci8+XG4gICAgeyNlYWNoIGZlZWRiYWNrIGFzIGl0ZW0gKGl0ZW0uY3JlYXRlZCl9XG5cdFx0ICB7I2lmIGl0ZW0uY3JlYXRlZCA+PSBjbGVhckRhdGV9XG4gICAgICBcdDxGZWVkYmFja1NlbnQgaXRlbT17aXRlbX0vPlxuICAgIFx0ey9pZn1cbiAgICB7L2VhY2h9XG4gIHs6ZWxzZX1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG5cdFx0XHRcdHsjaWYgIWluQ2xhc3N9XG5cdFx0XHRcdFx0PGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtlbnRlckNsYXNzfT5cblx0XHRcdFx0XHRcdDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+Q2xhc3MgSUQ8L2xhYmVsPlxuXHRcdFx0XHRcdFx0PGlucHV0IGNsYXNzPVwiaW5wdXQgaXMtbGFyZ2VcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiQ2xhc3MgSURcIiBiaW5kOnZhbHVlPXtjbGFzc0lkfT5cblx0XHRcdFx0XHQ8L2Zvcm0+XG5cdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHQ8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ9eygpID0+IHsgYWRkTmFtZShuYW1lKSB9fT5cblx0XHRcdFx0XHRcdDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+TmFtZTwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8aW5wdXQgY2xhc3M9XCJpbnB1dCBpcy1sYXJnZVwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJOYW1lXCIgYmluZDp2YWx1ZT17bmFtZX0+XG5cdFx0XHRcdFx0PC9mb3JtPlxuXHRcdFx0XHR7L2lmfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIHsvaWZ9XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7NkVBYThDLElBQUksQ0FBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzREFBbEIsSUFBSSxDQUFDLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FWdkQsTUFBSSxnQkFBSSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQ3NHVCxLQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQVJOLFFBQVE7OzRCQUFVLElBQUksQ0FBQyxPQUFPOztnQ0FBbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBUGlFLFdBQVc7aUNBR1gsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBSTVFOzs7Ozs7OzBCQUFLLFFBQVE7Ozs7Ozs7OztrQ0FBYjs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7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
